# Заметка о реализации проекта

**1. Архитектурное разделение (`app.py` и `logic.py`)**
*   **Проблема:** При использовании `ProcessPoolExecutor` внутри основного скрипта Streamlit, каждый новый процесс заново импортирует главный файл. Это приводило к рекурсивному запуску интерфейса и множеству ворнингов в консоли.
*   **Решение:** Логика вычислений и запросов вынесена в отдельный модуль `logic.py`. Теперь импортируются только функции, не затрагивая UI-код Streamlit.

**2. Асинхронная работа с API (`aiohttp`)**
Для сравнения производительности реализованы два подхода к получению погоды для списка городов:
*   **Синхронный (`requests`):** Блокирует выполнение на каждом запросе. Время выполнения растет с количеством городов.
*   **Асинхронный (`aiohttp` + `asyncio`):** Отправляет запросы практически одновременно.
*   **Результат:** Асинхронный подход показывает ускорение в 5-10 раз даже на малом списке городов (5 штук), так как ожидание ответа от сервера происходит параллельно.

**3. Параллелизм в вычислениях (`ProcessPoolExecutor`)**
Для анализа исторических данных (расчет скользящего среднего и поиск аномалий) использован модуль `concurrent.futures`. Данные разбиваются по городам, и каждый город обрабатывается в отдельном процессе.
*   На текущем объеме данных вычислительные расходы на создание процессов могут превышать выигрыш в скорости. Однако с ростом объёма данных будет и расти выигрыш от параллельной обработки.

**4. Типы данных**
Streamlit использует движок PyArrow для рендеринга таблиц, который строг к типам данных.
*   При использовании `df.describe()` возникал конфликт типов: числа смешивались с датами.
*   Решение: Использование `include=[np.number]` для фильтрации только числовых колонок, что устранило ошибки сериализации Arrow.

**5. Интерактивная визуализация**
Вместо статического `matplotlib` использован `plotly.graph_objects`. Это позволяет пользователю:
*   Зумить графики для детального просмотра аномалий.
*   Видеть точные значения при наведении курсора.
*   Отключать слои (например, скрыть скользящее среднее).

---

### Выводы о работе

1.  **Производительность I/O vs CPU:** Проект показал, что асинхронность критически важна для сетевых операций (I/O-bound), давая прирост скорости. В то же время, мультипроцессинг требует применения с осторожностью, и на малых данных он может работать медленнее последовательного кода из-за затрат на сериализацию данных и управление процессами.
2.  **Streamlit:** Фреймворк отлично подходит для быстрого создания приложений, но требует понимания того, как работает его модель выполнения (rerun script on interaction), особенно при работе с многопоточностью.
3.  **Анализ данных:** Алгоритм поиска аномалий через скользящее среднее показал себя как простой и эффективный метод для сезонных временных рядов, позволяя отсеивать локальные выбросы, не реагируя на естественную смену сезонов.